#include <SDL.h>
#include <SDL_ttf.h>
#include <SDL_mixer.h>
#include <iostream>
#include <string>
#include <vector>
using namespace std;

const int WINDOW_WIDTH = 600;
const int WINDOW_HEIGHT = 400;

void handleError(const string &message, SDL_Window *window, SDL_Renderer *renderer, TTF_Font *font, Mix_Chunk *alarm)
{
    cerr << message << " SDL Error: " << SDL_GetError() << endl;
    if (font)
        TTF_CloseFont(font);
    if (alarm)
        Mix_FreeChunk(alarm);
    Mix_CloseAudio();
    TTF_Quit();
    if (renderer)
        SDL_DestroyRenderer(renderer);
    if (window)
        SDL_DestroyWindow(window);
    SDL_Quit();
    exit(-1);
}

void initSDL(SDL_Window *&window, SDL_Renderer *&renderer, TTF_Font *&font, Mix_Chunk *&alarm)
{
    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) < 0)
        handleError("SDL không thể khởi tạo!", window, renderer, font, alarm);

    window = SDL_CreateWindow("Đồng hồ điện tử đếm ngược", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, WINDOW_WIDTH, WINDOW_HEIGHT, SDL_WINDOW_SHOWN);
    if (!window)
        handleError("Không thể tạo cửa sổ!", window, renderer, font, alarm);

    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
    if (!renderer)
        handleError("Không thể tạo renderer!", window, renderer, font, alarm);

    if (TTF_Init() == -1)
        handleError("TTF không thể khởi tạo!", window, renderer, font, alarm);

    font = TTF_OpenFont("data/digital.ttf", 50);
    if (!font)
        handleError("Không thể tải font!", window, renderer, font, alarm);

    if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 2048) < 0)
        handleError("SDL_mixer không thể khởi tạo!", window, renderer, font, alarm);

    alarm = Mix_LoadWAV("data/alarm.mp3");
    if (!alarm)
        handleError("Không thể tải âm thanh!", window, renderer, font, alarm);

    SDL_StartTextInput();
}

void closeSDL(SDL_Window *window, SDL_Renderer *renderer, TTF_Font *font, Mix_Chunk *alarm)
{
    if (font)
        TTF_CloseFont(font);
    if (alarm)
        Mix_FreeChunk(alarm);
    Mix_CloseAudio();
    TTF_Quit();
    if (renderer)
        SDL_DestroyRenderer(renderer);
    if (window)
        SDL_DestroyWindow(window);
    SDL_Quit();
}

string formatTime(int seconds)
{
    int hours = seconds / 3600;
    seconds %= 3600;
    int minutes = seconds / 60;
    int secs = seconds % 60;
    return (hours < 10 ? "0" : "") + to_string(hours) + ":" +
           (minutes < 10 ? "0" : "") + to_string(minutes) + ":" +
           (secs < 10 ? "0" : "") + to_string(secs);
}

void drawButton(SDL_Renderer *renderer, const string &label, SDL_Rect &buttonRect)
{
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    SDL_RenderFillRect(renderer, &buttonRect);

    TTF_Font *buttonFont = TTF_OpenFont("data/digital.ttf", 24);
    if (!buttonFont)
    {
        cerr << "Không thể tải font! TTF Error: " << TTF_GetError() << endl;
        return;
    }
    SDL_Color textColor = {0, 0, 0};
    SDL_Surface *textSurface = TTF_RenderText_Solid(buttonFont, label.c_str(), textColor);
    SDL_Texture *textTexture = SDL_CreateTextureFromSurface(renderer, textSurface);

    int textWidth, textHeight;
    SDL_QueryTexture(textTexture, NULL, NULL, &textWidth, &textHeight);
    SDL_Rect textRect = {buttonRect.x + (buttonRect.w - textWidth) / 2, buttonRect.y + (buttonRect.h - textHeight) / 2, textWidth, textHeight};

    SDL_RenderCopy(renderer, textTexture, NULL, &textRect);

    SDL_FreeSurface(textSurface);
    SDL_DestroyTexture(textTexture);
    TTF_CloseFont(buttonFont);
}

void drawTime(SDL_Renderer *renderer, TTF_Font *font, const string &timeText)
{
    SDL_Color textColor = {255, 255, 255};
    SDL_Surface *textSurface = TTF_RenderText_Solid(font, timeText.c_str(), textColor);
    SDL_Texture *textTexture = SDL_CreateTextureFromSurface(renderer, textSurface);

    int textWidth, textHeight;
    SDL_QueryTexture(textTexture, NULL, NULL, &textWidth, &textHeight);
    SDL_Rect renderQuad = {(WINDOW_WIDTH - textWidth) / 2, (WINDOW_HEIGHT - textHeight) / 2, textWidth, textHeight};

    SDL_RenderCopy(renderer, textTexture, NULL, &renderQuad);
    SDL_FreeSurface(textSurface);
    SDL_DestroyTexture(textTexture);
}

int inputTime(SDL_Renderer *renderer, TTF_Font *font)
{
    SDL_Color textColor = {0, 255, 0}; // Màu xanh lá cho đồng hồ
    string inputText = "000000";
    bool done = false;
    SDL_Event e;

    // Nút Start và Clear nằm ngay dưới đồng hồ
    SDL_Rect startButton = {WINDOW_WIDTH / 2 - 100, WINDOW_HEIGHT / 2 - 10, 80, 40};
    SDL_Rect clearButton = {WINDOW_WIDTH / 2 + 20, WINDOW_HEIGHT / 2 - 10, 80, 40};

    // Nút số từ 0 đến 4 ở hàng trên, từ 5 đến 9 ở hàng dưới
    vector<SDL_Rect> digitButtons(10);
    for (int i = 0; i < 5; ++i) // Hàng trên: 0-4
    {
        digitButtons[i] = {50 + i * 100, WINDOW_HEIGHT / 2 + 50, 80, 40};
    }
    for (int i = 5; i < 10; ++i) // Hàng dưới: 5-9
    {
        digitButtons[i] = {50 + (i - 5) * 100, WINDOW_HEIGHT / 2 + 110, 80, 40};
    }

    TTF_Font *largeFont = TTF_OpenFont("data/digital.ttf", 100);
    if (!largeFont)
    {
        cerr << "Không thể tải font! TTF Error: " << TTF_GetError() << endl;
        return 0;
    }

    while (!done)
    {
        while (SDL_PollEvent(&e) != 0)
        {
            if (e.type == SDL_QUIT)
            {
                done = true;
                exit(0);
            }
            else if (e.type == SDL_MOUSEBUTTONDOWN)
            {
                int x, y;
                SDL_GetMouseState(&x, &y);

                // Kiểm tra nhấn nút số
                for (int i = 0; i < 10; ++i)
                {
                    if (x >= digitButtons[i].x && x <= digitButtons[i].x + digitButtons[i].w &&
                        y >= digitButtons[i].y && y <= digitButtons[i].y + digitButtons[i].h)
                    {
                        inputText = inputText.substr(1) + to_string(i);
                    }
                }

                // Kiểm tra nút Start
                if (x >= startButton.x && x <= startButton.x + startButton.w &&
                    y >= startButton.y && y <= startButton.y + startButton.h)
                {
                    done = true;
                }

                // Kiểm tra nút Clear
                if (x >= clearButton.x && x <= clearButton.x + clearButton.w &&
                    y >= clearButton.y && y <= clearButton.y + clearButton.h)
                {
                    inputText = "000000";
                }
            }
        }

        // Xóa màn hình và hiển thị đồng hồ lớn màu xanh lá
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
        SDL_RenderClear(renderer);

        string formattedTime = inputText.substr(0, 2) + ":" + inputText.substr(2, 2) + ":" + inputText.substr(4, 2);

        SDL_Surface *textSurface = TTF_RenderText_Solid(largeFont, formattedTime.c_str(), textColor);
        SDL_Texture *textTexture = SDL_CreateTextureFromSurface(renderer, textSurface);

        int textWidth, textHeight;
        SDL_QueryTexture(textTexture, NULL, NULL, &textWidth, &textHeight);
        SDL_Rect renderQuad = {(WINDOW_WIDTH - textWidth) / 2, (WINDOW_HEIGHT - textHeight) / 2 - 80, textWidth, textHeight}; // Di chuyển lên cao hơn 30 pixel

        SDL_RenderCopy(renderer, textTexture, NULL, &renderQuad);
        SDL_FreeSurface(textSurface);
        SDL_DestroyTexture(textTexture);

        // Vẽ nút Start và Clear
        drawButton(renderer, "Start", startButton);
        drawButton(renderer, "Clear", clearButton);

        // Vẽ các nút số
        for (int i = 0; i < 10; ++i)
        {
            drawButton(renderer, to_string(i), digitButtons[i]);
        }

        SDL_RenderPresent(renderer);
    }

    TTF_CloseFont(largeFont);

    // Chuyển đổi input thành thời gian
    int hours = stoi(inputText.substr(0, 2));
    int minutes = stoi(inputText.substr(2, 2));
    int seconds = stoi(inputText.substr(4, 2));

    return hours * 3600 + minutes * 60 + seconds;
}

void drawProgressBar(SDL_Renderer *renderer, int totalTime, int remainingTime)
{
    int barWidth = WINDOW_WIDTH - 100;
    int barHeight = 20;
    int filledWidth = (remainingTime * barWidth) / totalTime;

    SDL_Rect progressBar = {50, 20, barWidth, barHeight};
    SDL_Rect filledBar = {50, 20, filledWidth, barHeight};

    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    SDL_RenderFillRect(renderer, &progressBar);

    SDL_SetRenderDrawColor(renderer, 0, 255, 0, 255);
    SDL_RenderFillRect(renderer, &filledBar);
}

bool runCountdown(SDL_Renderer *renderer, TTF_Font *font, Mix_Chunk *alarm, int &countdownTime)
{
    SDL_Color textColor = {0, 255, 0};
    SDL_Color pausedTextColor = {255, 0, 0};
    bool running = true;
    bool paused = false;
    SDL_Event e;
    Uint32 startTime = SDL_GetTicks();
    Uint32 pauseStartTime = 0;
    int lastRemainingTime = -1;
    int elapsedPausedTime = 0;

    SDL_Rect pauseButton = {WINDOW_WIDTH / 2 - 100, WINDOW_HEIGHT - 60, 80, 40};
    SDL_Rect resetButton = {WINDOW_WIDTH / 2 + 20, WINDOW_HEIGHT - 60, 80, 40};

    TTF_Font *largeFont = TTF_OpenFont("data/digital.ttf", 100);
    if (!largeFont)
    {
        cerr << "Không thể tải font! TTF Error: " << TTF_GetError() << endl;
        return false;
    }

    if (countdownTime == 0)
    {
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
        SDL_RenderClear(renderer);

        string timeText = "TIME OUT";
        Mix_PlayChannel(-1, alarm, 0);

        SDL_Surface *textSurface = TTF_RenderText_Solid(largeFont, timeText.c_str(), textColor);
        SDL_Texture *timeTexture = SDL_CreateTextureFromSurface(renderer, textSurface);
        SDL_FreeSurface(textSurface);

        int textWidth, textHeight;
        SDL_QueryTexture(timeTexture, NULL, NULL, &textWidth, &textHeight);
        SDL_Rect renderQuad = {(WINDOW_WIDTH - textWidth) / 2, (WINDOW_HEIGHT - textHeight) / 2, textWidth, textHeight};

        SDL_RenderCopy(renderer, timeTexture, NULL, &renderQuad);
        SDL_DestroyTexture(timeTexture);

        resetButton.x = (WINDOW_WIDTH - resetButton.w) / 2;
        drawButton(renderer, "Reset", resetButton);

        SDL_RenderPresent(renderer);

        bool reset = false;
        while (!reset)
        {
            while (SDL_PollEvent(&e) != 0)
            {
                if (e.type == SDL_QUIT)
                {
                    running = false;
                    reset = true;
                }
                else if (e.type == SDL_MOUSEBUTTONDOWN)
                {
                    int x, y;
                    SDL_GetMouseState(&x, &y);

                    if (x >= resetButton.x && x <= resetButton.x + resetButton.w &&
                        y >= resetButton.y && y <= resetButton.y + resetButton.h)
                    {
                        TTF_CloseFont(largeFont);
                        return true;
                    }
                }
            }
        }
    }

    while (running)
    {
        while (SDL_PollEvent(&e) != 0)
        {
            if (e.type == SDL_QUIT)
            {
                running = false;
            }
            else if (e.type == SDL_MOUSEBUTTONDOWN)
            {
                int x, y;
                SDL_GetMouseState(&x, &y);

                if (x >= pauseButton.x && x <= pauseButton.x + pauseButton.w &&
                    y >= pauseButton.y && y <= pauseButton.y + pauseButton.h && lastRemainingTime > 0)
                {
                    paused = !paused;
                    if (paused)
                    {
                        pauseStartTime = SDL_GetTicks();
                    }
                    else
                    {
                        elapsedPausedTime += SDL_GetTicks() - pauseStartTime;
                    }
                }

                if (x >= resetButton.x && x <= resetButton.x + resetButton.w &&
                    y >= resetButton.y && y <= resetButton.y + resetButton.h)
                {
                    TTF_CloseFont(largeFont);
                    return true;
                }
            }
        }

        if (!paused)
        {
            Uint32 currentTime = SDL_GetTicks();
            int elapsedSeconds = (currentTime - startTime - elapsedPausedTime) / 1000;
            int remainingTime = countdownTime - elapsedSeconds;

            if (remainingTime < 0)
            {
                remainingTime = 0;
            }

            if (remainingTime != lastRemainingTime)
            {
                lastRemainingTime = remainingTime;

                string timeText = (remainingTime > 0) ? formatTime(remainingTime) : "TIME OUT";

                if (remainingTime == 0)
                {
                    Mix_PlayChannel(-1, alarm, 0);
                }

                SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
                SDL_RenderClear(renderer);

                drawProgressBar(renderer, countdownTime, remainingTime);

                SDL_Surface *textSurface = TTF_RenderText_Solid(largeFont, timeText.c_str(), textColor);
                SDL_Texture *timeTexture = SDL_CreateTextureFromSurface(renderer, textSurface);
                SDL_FreeSurface(textSurface);

                int textWidth, textHeight;
                SDL_QueryTexture(timeTexture, NULL, NULL, &textWidth, &textHeight);
                SDL_Rect renderQuad = {(WINDOW_WIDTH - textWidth) / 2, (WINDOW_HEIGHT - textHeight) / 2, textWidth, textHeight};

                SDL_RenderCopy(renderer, timeTexture, NULL, &renderQuad);
                SDL_DestroyTexture(timeTexture);

                if (remainingTime > 0)
                {
                    drawButton(renderer, paused ? "Resume" : "Pause", pauseButton);
                    drawButton(renderer, "Reset", resetButton);
                }
                else
                {
                    resetButton.x = (WINDOW_WIDTH - resetButton.w) / 2;
                    drawButton(renderer, "Reset", resetButton);
                }

                SDL_RenderPresent(renderer);
            }
        }
        else
        {
            SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
            SDL_RenderClear(renderer);

            SDL_Surface *pausedSurface = TTF_RenderText_Solid(font, "Paused", pausedTextColor);
            SDL_Texture *pausedTexture = SDL_CreateTextureFromSurface(renderer, pausedSurface);
            SDL_FreeSurface(pausedSurface);

            int pausedTextWidth, pausedTextHeight;
            SDL_QueryTexture(pausedTexture, NULL, NULL, &pausedTextWidth, &pausedTextHeight);
            SDL_Rect pausedRect = {(WINDOW_WIDTH - pausedTextWidth) / 2, (WINDOW_HEIGHT - pausedTextHeight) / 4, pausedTextWidth, pausedTextHeight};
            SDL_RenderCopy(renderer, pausedTexture, NULL, &pausedRect);
            SDL_DestroyTexture(pausedTexture);

            string timeText = formatTime(lastRemainingTime);
            SDL_Surface *textSurface = TTF_RenderText_Solid(largeFont, timeText.c_str(), textColor);
            SDL_Texture *timeTexture = SDL_CreateTextureFromSurface(renderer, textSurface);
            SDL_FreeSurface(textSurface);

            int textWidth, textHeight;
            SDL_QueryTexture(timeTexture, NULL, NULL, &textWidth, &textHeight);
            SDL_Rect renderQuad = {(WINDOW_WIDTH - textWidth) / 2, (WINDOW_HEIGHT - textHeight) / 2, textWidth, textHeight};

            SDL_RenderCopy(renderer, timeTexture, NULL, &renderQuad);
            SDL_DestroyTexture(timeTexture);

            drawButton(renderer, "Resume", pauseButton);
            drawButton(renderer, "Reset", resetButton);

            SDL_RenderPresent(renderer);
        }

        SDL_Delay(1000 / 60);
    }

    TTF_CloseFont(largeFont);
    return false;
}

int main(int argc, char *argv[])
{
    SDL_Window *window = NULL;
    SDL_Renderer *renderer = NULL;
    TTF_Font *font = NULL;
    Mix_Chunk *alarm = NULL;

    initSDL(window, renderer, font, alarm);

    bool reset = false;
    do
    {
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
        SDL_RenderClear(renderer);
        SDL_RenderPresent(renderer);

        int countdownTime = inputTime(renderer, font);

        reset = runCountdown(renderer, font, alarm, countdownTime);
    } while (reset);

    closeSDL(window, renderer, font, alarm);

    return 0;
}